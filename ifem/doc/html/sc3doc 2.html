
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Simplicial Complex in Three Dimensions</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-10-26"><meta name="DC.source" content="sc3doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Simplicial Complex in Three Dimensions</h1><!--introduction--><p>We dsecribe the data structure of the simplicial complex associated to a two dimensional trianglulation give by <tt>node,elem</tt> . The <tt>node</tt> records the coordinates of vertices and <tt>elem</tt> is the pointer from local to global incices of vertices. See <a href="meshbasicdoc.html">Basic mesh data structure</a>.</p><p>A brief summary of ordering and orientation</p><div><ul><li>edge: asecond ordering, i.e. edge(:,1)&lt;edge(:,2)</li></ul></div><div><ul><li>face: asecond ordering, i.e. face(:,1)&lt;face(:,2)&lt;face(:,3)</li></ul></div><div><ul><li>elem: positive ordering or ascend ordering. The default one is positive ordering and the asecond ordering is used for edge and face elements.</li></ul></div><p>Functions to call</p><pre>[elem2edge,edge,elem2edgeSign] = dof3edge(elem);
[elem2face,face,elem2faceSign] = dof3face(elem);</pre><p>Functions to read on the usage</p><pre>Poisson3RT0;
Maxwell;
Maxwell2;</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Indexing of Simplexes</a></li><li><a href="#8">Generate <tt>edge</tt> and <tt>face</tt> and Index Pointers</a></li><li><a href="#14">Ordering of Vertices</a></li><li><a href="#20">Orientation of Simplexes</a></li><li><a href="#27">Ascend Odering and Orientation</a></li><li><a href="#28">Positive Ordering and Orientation</a></li><li><a href="#29">An Example</a></li><li><a href="#30">Boundary Faces and Boundary Conditions</a></li></ul></div><p>The basic data structure of a mesh consists of node and elem:</p><pre class="codeinput">elem = [1 4 5 8; 1 4 5 7];
node = [1,0,0; 1,1,1; 1,-1,-1; 0,1,0; -2,-1,0; 1,1,-1; 0,1,1; 0,-1,-1];
</pre><p>The corresponding simplicial complex consists of vertices, edges, faces and tetrahedron. We shall discuss three issues</p><div><ul><li><b>Indexing</b> of simplexes</li><li><b>Ordering</b> of vertices</li><li><b>Orientation</b> of simplexes</li></ul></div><p>The indexing and ordering are related and the ordering and orientation are mixed together. However the indexing has nothing to do with the orientation. The indexing and ordering is the combinatory structure, i.e. only <tt>elem</tt> is needed, while the orientation also depends on <tt>node</tt>, the geometry emembdding of vertices.</p><p>For indexing, ordering, and orientation, there are always local and global version. The relation between the local and global version is the most complicated issue.</p><h2>Indexing of Simplexes<a name="3"></a></h2><p>The indexing refers to the numbering of simplexes, e.g., which face/edge is numbered as the first one. There are two types of indexing: local and global. In the assembling procedure of finite element methods, an element-wise matrix using local indexing is first computed and then assembled to get a big matrix using global indexing. Thus the pointer from local indexing to global indexing is indispensible. And for bases independent of the ordering and orientation, e.g., P1 and P2 elements, the pointer is sufficient. Otherwise the inconsistency of local ordering/orientation and global ordering/orientation should be take into account.</p><p><b>Local indexing</b></p><p>The tetrahedron consists of four vertices indexed as [1 2 3 4]. Each tetrahedron contains four faces and six edges. They can be indexed as</p><pre class="codeinput">locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
</pre><p>In <tt>locFace</tt>, the i-th face is opposite to the i-th vertices and thus this is called <i>opposite indexing</i>. In <tt>locEdge</tt>, it is the <i>lexicographic indexing</i> which is induced from the lexicographic ordering of the six edges. The ordering of vertices of each face or edge will not change the indexing. For example, the following <tt>locFacec</tt> and <tt>locEdged</tt> has the same indexing as <tt>locFace</tt> and <tt>locEdge</tt> but a different ordering of vertices.</p><pre class="codeinput">locFacec = [2 3 4; 1 4 3; 1 2 4; 1 3 2];
locEdge = [2 1; 3 1; 4 1; 3 2; 4 2; 4 3];
</pre><p>Indeed any permuation of each simplex will represent the same simplex and will not change the indexing. The ordering of vertices will affect the orientation and will be discussed later.</p><p>For a face consists of three vertices [1 2 3], there are two indexing schemes of its three edges.</p><div><ol><li>Oppoiste indexing        <tt>[2 3; 3 1; 1 2]</tt></li><li>Lexicographic indexing   <tt>[1 2; 1 3; 2 3]</tt></li></ol></div><p>Each indexing scheme has its advantange and disadavantange and which one to chose depends on the ordering and orientation consideration.</p><p><b>Global indexing and vertex pointer</b></p><p>Each simplex in the simplicial complex has a unqiuely index. It is represented by vertices pointer from the local index to the globa index of vertices.</p><p>The matrix <tt>elem</tt> is the pointer from local to global indices of vertices of tetrahedron, e.g. <tt>elem(t,1)=25</tt> means the first vertex of the tetrahedron t is the 25-th vertex.</p><p>Similarly the <tt>NE</tt> by 2 matrix <tt>edge</tt> records all edges and the <tt>NF</tt> by 3 matrix <tt>face</tt> records all faces of the triangulation. These are vertices pointers. We shall discuss the elementwise pointer from local indices to global indices for edges and faces.</p><h2>Generate <tt>edge</tt> and <tt>face</tt> and Index Pointers<a name="8"></a></h2><p>One can easily collect edges and faces elementwise. The issue is the duplication. For example, each interior face will be counted twice. The <tt>unique</tt> function is applied such that each edge or face has a unique global index.</p><p><b>Edge and Face</b></p><pre class="codeinput">totalEdge = uint32([elem(:,[1 2]); elem(:,[1 3]); elem(:,[1 4]); <span class="keyword">...</span>
                    elem(:,[2 3]); elem(:,[2 4]); elem(:,[3 4])]);
sortedTotalEdge = sort(totalEdge,2);
[edge, NULL, je] = unique(sortedTotalEdge,<span class="string">'rows'</span>);

totalFace = uint32([elem(:,[2 3 4]); elem(:,[1 4 3]); <span class="keyword">...</span>
                    elem(:,[1 2 4]); elem(:,[1 3 2])]);
sortedTotalFace = sort(totalFace,2);
[face, i2, jf] = unique(sortedTotalFace,<span class="string">'rows'</span>);
</pre><p>In iFEM, <tt>N,NE,NF,NT</tt> represents the number of vertices, edges, faces and tetrahedrons, resprectively.</p><pre class="codeinput">N = size(node,1); NT = size(elem,1); NF = size(face,1); NE = size(edge,1);
</pre><p>In the assembling procedure, the matrix is always computed elementwise and then assemble to a big one. A pointer from the local index of a simplex to its global index is thus indispensible.</p><p><b>Elementwise pointers</b></p><div><ul><li><tt>elem2node = elem</tt></li><li><tt>elem2face(1:NT, 1:4)</tt></li><li><tt>elem2edge(1:NT, 1:6)</tt></li></ul></div><p>Such information is exactly stored in the output of <tt>unique</tt> function. For example, elem2face(t,1) = 17 means the first face of t (spanned by [2 3 4]) is the 17-th element in the <tt>face</tt> matrix.</p><pre class="codeinput">elem2edge = uint32(reshape(je,NT,6));
elem2face = uint32(reshape(jf,NT,4));
</pre><p><b>Face to edge Pointer</b></p><p><tt>face2edge(1:NF,1:3)</tt> records the global indices of three edges of a face. This pointer depends on the ordering of vertices of faces and the indexing of local edges in a face. We list the following two important cases. Other combinations is possible but not attractive.</p><div><ul><li>Ascend ordering.</li></ul></div><p>All locaal faces and local edges are ascend ordered.</p><pre class="codeinput">locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
edgeofFace = [1 2; 1 3; 2 3];
locface2edge = [4 5 6; 2 3 6; 1 3 5; 1 2 4];
</pre><div><ul><li>Consistent ordering</li></ul></div><p>The local face is ordered such that the corresponding orientation is consistent with the induced orientation.</p><pre class="codeinput">locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
edgeofFace = [2 3; 3 1; 1 2];
locface2edge = [6 5 4; 6 2 3; 5 3 1; 4 1 2];
</pre><p>The global one can be obtained from the composition of <tt>elem2face</tt> and <tt>locface2edge</tt>. For example, for the asecnd ordering scheme,</p><pre class="codeinput">face2edge(elem2face(:,1),:) = elem2edge(:,[4 5 6]);
face2edge(elem2face(:,2),:) = elem2edge(:,[2 3 6]);
face2edge(elem2face(:,3),:) = elem2edge(:,[1 3 5]);
face2edge(elem2face(:,4),:) = elem2edge(:,[1 2 4]);
</pre><h2>Ordering of Vertices<a name="14"></a></h2><p>We discuss the ordering of vertices of simplexes. Again there are local ordering and global ordering. They may not be consistent and a sign array is used to record the inconsistency if any.</p><p>The local ordering refers to the ordering of vertices in <tt>locFace</tt> or <tt>locEdge</tt>, i.e. the ordering of the local index of vertices. For elements associated to faces or edges, the local ordering could be used in the formulation of the local basis and thus the ordering does matter.</p><p>The global ordering refers to the ordering of vertices in <tt>face</tt> or <tt>edge</tt>, i.e., the ordering of the global index of vertices. Note that that in either local or global ordering, permutation of vertices will represent the same simplex. To fix an ordering we need extra information.</p><p><b>elem</b>. The local ordering is always [1 2 3 4]. Any permutation of four vertices of a tetrahedon still represents the same tetrahedron. Such freedom provide a room to record more information like:</p><div><ul><li>global ordering of vertices</li><li>orientation of element</li><li>refinement rule</li></ul></div><p>In 2-D, three vertices of a triangle is sorted counter-clockwise and the first vertex is chosen as the newest vertex. Such ordering enables the efficient implementation of local refinement and coarsening in 2-D; see <a href="bisectdoc.html">Bisection in Two Dimensions</a> and <a href="coarsendoc.html">Coarsening in Two Dimensions</a>. In 3-D, for the longest edge bisection, the newest vertex (with the highest generation) is stored as the last (4-th) vertex of a tetrahedron. For <a href="uniformrefine3doc.html">3-D Red Refinement</a>, the ordering determines the shape regularity of refined triangulation. Permuation of vertices in <tt>elem</tt> could deterioriate the angle condition after the refinement.</p><p>We shall reserve the ordering of <tt>elem</tt> for the mesh refinement and coarsening since they are more subtle. We switch the ordering when generating data structure for finite element basis and assemble the matrix equation. Such sorting is hidden in the subroutines when a finite element basis requiring ordering is generated.</p><p>Two types of ordering of <tt>elem</tt> is of particular importantance</p><div><ul><li>Positive ordering</li><li>Ascend ordering</li></ul></div><p>In the positive ordering, the four vertices are ordered such that the signed volume, the mix product of vectors (v12,v13,v14), is positive. This is the default ordering used so far. <tt>fixorder3</tt> will switch the vertices for elements with negative volume.</p><div><ul><li><tt>v = simplexvolume(node,elem)</tt> returns the singed area</li><li><tt>elem = fixorder(node,elem)</tt> switchs the vertices for elements with negative area.</li></ul></div><p>In ascend ordering, the vertices of <tt>elem</tt> is sorted such that <tt>elem(t,1) &lt; elem(t,2) &lt; elem(t,3) &lt; elem(t,4)</tt>. Such ordering will benefit the construction of local bases for high order basis or basis with orientation. This can be easily achieved by <tt>elem = sort(elem,2)</tt>. Howevery, one has to rotate the boundary flag accordingly using</p><pre class="codeinput">elem = sortelem3(elem);
</pre><p><b>edge</b>. For 3-D triangulations, we chose the ascend ordering both locally and globally. Namely</p><pre class="codeinput">locEdge(:,1) &lt; locEdge(:,2);
edge(:,1) &lt; edge(:,2);
</pre><p>Recall that for locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4], it is ascend ordered. The <tt>edge</tt> produced by <tt>unique</tt> function is also ascend ordered.</p><p>There might be a inconsistency between the local and global ordering. That is <tt>edge(elem2edge(t,1),1)</tt> may not be smaller than <tt>edge(elem2edge(t,1),2)</tt>. It will be more clear from the discussion of the corresponding orientation.</p><p>For 2-D triangulations, the global ordering is still ascend ordered. But locally it may not. For example, for consisitent ordering <tt>locEdge = [2 3; 3 1; 1 2]</tt>, then <tt>locEdge(2,1) &gt; locEdge(2,2)</tt>.</p><p><b>face</b>. For 3-D triangulations, the <tt>face</tt> produced by <tt>unique</tt> function is already sorted in the second dimension such that the global ordering is ascended i.e. <tt>face(:,1) &lt; face(:,2) &lt; face(:,3)</tt>. The local ordering in <tt>locFace</tt>, however, is not always ascend ordered.</p><pre class="codeinput">locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3]; <span class="comment">% Ascend ordering</span>
locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2]; <span class="comment">% Consistent ordering</span>
</pre><p>Again the local and global ordering maynot be consisitent. That is <tt>face(elem2face(t,:),1) &lt; face(elem2face(t,:),2) &lt; face(elem2face(t,:),3)</tt> maynot be true.</p><h2>Orientation of Simplexes<a name="20"></a></h2><p>The orientation of a tetrahedron is either positive or negative. The orientation of a face is given by a normal vector and the orientation of an edge is by a tangential vector.</p><p>The orientation of a d-simplex will induce an orientation of its d-1 subcomplex and is called <i>induced orientation</i>. For example, a positive orientated tetrahedron will induce the outwards normal orientation of its four faces and a positive orientated triangle will induce the counter clockwise orientation of its three edges.</p><p>The ordering of vertices of a simplex will naturally introduce an orientation and will be called <i>ordering orientation</i>. More specifically</p><div><ul><li>the vector from edge(:,1) to edge(:,2) defines an orientation of edges.</li><li>the <tt>cross(v12,v13)</tt> defines an orientation of a face, where <tt>vij</tt> is the vector from <tt>face(:,i)</tt> to <tt>face(:,j)</tt>.</li><li>the sign of the mix product <tt>sign(v12, v13, v14)</tt> defines an orientation for tetrahedrons.</li></ul></div><p>The orientation of a simplex in the simplicial complex should be uniquely determined which will be called <i>global orientation</i>. It can be chosen as the global ordering orientation but not always.</p><p>Inside one tetrahedron, the local ordering of local edges and local faces will introduce a corresponding orientation. The orientation of the tetrahedron will also induce an orientation for its four faces. These are called <i>local orientation</i> which may not be consisitent with the global orientation. The local ordering orientation is used in the local basis and the induced orientation is used when computing the differential operator locally.</p><p>In general, there will be a inconsistency of the following several types of orientation and apporipate data structure should be constructured to record such inconsistency.</p><div><ul><li>a global orientation</li><li>the global ordering orientation</li><li>the local ordering orientation inside a tetrahedron</li><li>the local induced orientation inside a tetrahedron</li></ul></div><p><b>elem</b>. The orientation of a tetraheron is either positive or negative. We chose the global ordering orientation, i.e., the sign of the signed volume.</p><pre class="codeinput">[Dlambda,volume,elemSign] = gradbasis3(node,elem);
</pre><p>In the output of <tt>gradbasis3</tt>, <tt>volume</tt> is always positive and an additional array <tt>elemSign</tt> is used to record the sign of the signed volume.</p><p><tt>Dlambda(t,:,k)</tt> is the gradient of <img src="sc3doc_eq12824216610100386060.png" alt="$\lambda_k$">. Therefore the outward normal direction of the kth face can be obtained by <tt>-Dlambda(t,:,k)</tt> which is independent of the ordering and orientation.</p><p><b>face</b>. The global ordering orientation. The normal vector is given by <tt>cross(v12,v13)</tt>.</p><p>The local ordering orientation is implicitly used when computing finite element basis in each element. For example, the RT0 basis on face <tt>[i j k]</tt> in <tt>locFace</tt> is defined as</p><p><img src="sc3doc_eq09291986701580068970.png" alt="$$\phi_{i,j,k} = 2(\lambda_i&#xA;\nabla \lambda_j \times \nabla \lambda_k+ \lambda_j&#xA;\nabla \lambda_k \times \nabla \lambda_i+\lambda_k&#xA;\nabla \lambda_i \times \nabla \lambda_j).$$"></p><p>Odd permutation of <tt>[i j k]</tt> will change the sign of the basis. The direction of <img src="sc3doc_eq01088982207552417912.png" alt="$\phi_{i,j,k}$"> is the normal vector determined by <tt>[i,j,k]</tt> ordering. Note that this is locally, i.e., element by element.</p><p>The global basis associated to a face, however, depends only on the global orientation of this face. We introduce <tt>elem2faceSign(1:NT, 1:4)</tt> to record the inconsistency of a local ordering orientation and a global orientation.</p><p>For locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2], i.e. the induced ordering, the elem2faceSign can be obtained from <tt>dof3face</tt></p><pre class="codeinput">totalFace = [elem(:,[2 3 4]); elem(:,[1 4 3]); elem(:,[1 2 4]); elem(:,[1 3 2])];
elem2faceSign = reshape(sum(sign(diff(totalFace(:,[1:3,1]),1,2)),2),NT,4);
</pre><p>When both <tt>elem</tt> and <tt>locFace</tt> are ascend ordered, the orientation of the global ordering is consistent with the local ordering. Thus <tt>elem2faceSign</tt> is not needed for ascending ordering when assembling matrices of weak form.</p><p>But for asecond ordering system, an <tt>elem2faceSign</tt> will be used when assembling differential operators. For example, when computing <tt>div</tt> operators on a positive orientated tetrahedron, the faces should be orientated by the outwards normal direction but the global faces may not be.</p><p>If <tt>elem</tt> is positive ordered and <tt>locFace</tt> is consistently ordered, then this inconsistency is already recorded in <tt>elem2faceSign</tt>.</p><p>For ascend ordering of <tt>elem</tt>, we denote the direction as +1 if the direction of a face is the same with the induced normal direction in a certain elem, and -1 otherwise. Then the consistency is given by</p><pre class="codeinput">elem2faceSign = [+1 -1 +1 -1];
</pre><p><b>edge</b>. The orientation of edges is simpler than faces. Globally we always chose the global ascend ordering orientation. Namely the orientation of an edge is from the smaller index to larger index.</p><p>Locally the local ascend ordering may not be consistent with the global one. See <a href="dof3edgedoc.html">Data Structure: Lowest Order Edge Element</a>.</p><pre class="codeinput">totalEdge = uint32([elem(:,[1 2]); elem(:,[1 3]); elem(:,[1 4]); <span class="keyword">...</span>
                    elem(:,[2 3]); elem(:,[2 4]); elem(:,[3 4])]);
direction = ones(6*NT,1,<span class="string">'int8'</span>);
idx = (totalEdge(:,1)&gt;totalEdge(:,2));
direction(idx) = -1;
elem2edgeSign = reshape(direction,NT,6);
</pre><p>For ascend ordering of <tt>elem</tt> and <tt>locEdge</tt>, the local and global orientation will be consistent and no <tt>elem2edgeSign</tt> is needed!</p><p><b>face to edge</b>. For the ascend ordering <tt>edgeofFace = [1 2; 1 3; 2 3]</tt>, the local and global ordering is consistent and so is the orientation. But it is not consisitent with the induced positive (counter clockwise) orientation of edges. When the edge direction is the same with the local counter clockwise direction, we set the direction as +1, otherwise -1. Then</p><pre class="codeinput">face2edgeSign = [+1 -1 +1];
</pre><p>For the consistent ordering, <tt>edgeofFace = [2 3; 3 1; 1 2]</tt> which is consisent with the induced positive orientation but not consistent with the global orientation of edges. We construct <tt>face2edgeSign</tt> as</p><pre class="codeinput">totalEdge = [face(:,[2 3]); face(:,[3 1]); face(:,[1 2])];
direction = ones(3*NF,1);
idx = (totalEdge(:,1)&gt;totalEdge(:,2));
direction(idx) = -1;
face2edgeSignp = reshape(direction,NF,3);
</pre><p>We summarize the two popular ordering and orientation schemes below.</p><h2>Ascend Odering and Orientation<a name="27"></a></h2><p><b>Ascend ordering</b>. The vertices of <tt>elem</tt> is sorted such that</p><p><tt>elem(i,1) &lt; elem(i,2) &lt; elem(i,3) &lt; elem(i,4)</tt>.</p><p>The local face and local edges is also in the ascend ordering</p><div><ul><li><tt>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];</tt></li><li><tt>locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];</tt></li><li><tt>edgeofFace = [1 2; 1 3; 2 3];</tt></li></ul></div><p>Then due to the asecond ordering of <tt>elem</tt>, globally the <tt>edge</tt> and <tt>face</tt> also follow the ascend ordering, i.e.</p><div><ul><li><tt>edge(e,1) &lt; edge(e,2)</tt></li><li><tt>face(f,1) &lt; face(f,2) &lt; face(f,3)</tt></li></ul></div><p>One can easily see the benefit: the ordering of local edges and local faces is consistent with the global ones and so is their corresponding orientation.</p><p><b>Orientation</b>. We chose the global ordering orientation for each elment. We chose the orientation corresponding to the ascend ordering for edges and faces. We summarize as</p><div><ul><li>elem: <tt>sign(v12,v13,v14)</tt></li><li>face: the normal vector is given by <tt>cross(v12,v13)</tt></li><li>edge: from the node with smaller global index to bigger one</li></ul></div><p>For faces and edges, the orientation of the global ordering and the local ordering of faces and edges is consistent. The inconsistency of the ordering orientation and the induced orienation is recorded by</p><div><ul><li>elem2faceSign = [+1 -1 +1 -1];</li><li>face2edgeSign = [+1 -1 +1];</li></ul></div><h2>Positive Ordering and Orientation<a name="28"></a></h2><p><b>Positive and consistent ordering</b>. The vertices of <tt>elem</tt> is sorted such that the signed volume is always positive, i.e. the four vertices follows the right hand rule.</p><p>The local face is ordered consistently as</p><p><tt>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];</tt></p><p>The local edge is still ascend ordered</p><p>locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];</p><p>Three edges of a face is ordered consistently</p><p>edgeofFace = [2 3; 3 1; 1 2];</p><p><b>Orientation</b></p><p>The ascend ordering orientation is used for global edges and faces. The inconsistency of the local and global orientation is recorded in <tt>elem2faceSign</tt> and <tt>elem2edgeSign</tt>.</p><h2>An Example<a name="29"></a></h2><p>We show two tetrahedron with ascend ordering.</p><pre class="codeinput">elem = [1 4 5 8; 1 4 5 7];
figure(1);clf;
showmesh3(node,elem);
view(-1,32);
findnode3(node,[1,2,3,4,5,7,8]);
findelem3(node,elem);
findedge(node,edge,<span class="string">'all'</span>,<span class="string">'vec'</span>);
findelem(node,face);
snapnow;
display(edge); display(elem2edge);
display(face); display(elem2face);
display(elemSign);
display(elem2faceSign);
display(face2edgeSign);
</pre><img vspace="5" hspace="5" src="sc3doc_01.png" alt=""> <pre class="codeoutput">
edge =

           1           4
           1           5
           1           7
           1           8
           4           5
           4           7
           4           8
           5           7
           5           8


elem2edge =

           1           2           4           5           7           9
           1           2           3           5           6           8


face =

           1           4           5
           1           4           7
           1           4           8
           1           5           7
           1           5           8
           4           5           7
           4           5           8


elem2face =

           7           5           3           1
           6           4           2           1


elemSign =

    -1
     1


elem2faceSign =

     1    -1     1    -1


face2edgeSign =

     1    -1     1

</pre><h2>Boundary Faces and Boundary Conditions<a name="30"></a></h2><p>We use <tt>bdFlag</tt> to record the boundary condition; see <a href="bddoc.html">Data Structure: Boundary Conditions</a> for details. For short, <tt>bdFlag</tt> has the same size with <tt>elem</tt>, and point to the boundary type of each local faces. If we change the ordering of <tt>elem</tt>, the corresponding local faces are changed. Threfore when we sort the <tt>elem</tt>, we should sort the <tt>bdFlag</tt> respectively. We use <tt>sortelem3</tt> to sort elem and bdFlag at the same time. Note that <tt>sort(elem,2)</tt> sorts the <tt>elem</tt> only, and leave <tt>bdFlag</tt> unchanged.</p><pre class="codeinput">[node,elem] = cubemesh([-1,1,-1,1,-1,1],2);
bdFlag = setboundary3(node,elem,<span class="string">'Dirichlet'</span>,<span class="string">'x==1'</span>,<span class="string">'Neumann'</span>,<span class="string">'x~=1'</span>);
figure(2);clf;
showmesh3(node,elem);
display(elem); display(bdFlag);
findnode3(node,[1,2,3,4,5,7,8]);
[elem,bdFlag] = sortelem3(elem,bdFlag);
display(elem); display(bdFlag);
</pre><pre class="codeoutput">
elem =

     1     2     3     7
     1     4     3     7
     1     5     6     7
     1     5     8     7
     1     2     6     7
     1     4     8     7


bdFlag =

    1    0    0    2
    2    0    0    2
    2    0    0    2
    2    0    0    2
    1    0    0    2
    2    0    0    2


elem =

     1     2     3     7
     1     3     4     7
     1     5     6     7
     1     5     7     8
     1     2     6     7
     1     4     7     8


bdFlag =

    1    0    0    2
    2    0    0    2
    2    0    0    2
    2    0    2    0
    1    0    0    2
    2    0    2    0

</pre><img vspace="5" hspace="5" src="sc3doc_02.png" alt=""> <p>We can use <tt>bdFlag</tt> to find the boundary nodes, edges and faces. To find the outwords normal direction of the boundary face, we need the help of the <tt>gradbasis3</tt>. In the output of <tt>gradbasis3</tt>, <tt>Dlambda(t,:,k)</tt> is the gradient of <img src="sc3doc_eq12824216610100386060.png" alt="$\lambda_k$">. Therefore the outward normal direction of the kth face can be obtained by <tt>-Dlambda(t,:,k)</tt> which is independent of the ordering and orientation.</p><pre class="codeinput">Dlambda = gradbasis3(node,elem);
T = auxstructure3(elem);
elem2face = T.elem2face;
face = T.face;
NF = size(face,1);
<span class="keyword">if</span> ~isempty(bdFlag)
    <span class="comment">% Find Dirchelt boundary faces and nodes</span>
    isBdFace = false(NF,1);
    isBdFace(elem2face(bdFlag(:,1) == 1,1)) = true;
    isBdFace(elem2face(bdFlag(:,2) == 1,2)) = true;
    isBdFace(elem2face(bdFlag(:,3) == 1,3)) = true;
    isBdFace(elem2face(bdFlag(:,4) == 1,4)) = true;
    DirichletFace = face(isBdFace,:);
    <span class="comment">% Find outwards normal direction of Neumann boundary faces</span>
    bdFaceOutDirec = zeros(NF,3);
    bdFaceOutDirec(elem2face(bdFlag(:,1) == 2,1),:) = -Dlambda(bdFlag(:,1) == 2,:,1);
    bdFaceOutDirec(elem2face(bdFlag(:,2) == 2,2),:) = -Dlambda(bdFlag(:,2) == 2,:,2);
    bdFaceOutDirec(elem2face(bdFlag(:,3) == 2,3),:) = -Dlambda(bdFlag(:,3) == 2,:,3);
    bdFaceOutDirec(elem2face(bdFlag(:,4) == 2,4),:) = -Dlambda(bdFlag(:,4) == 2,:,4);
<span class="keyword">end</span>
<span class="comment">% normalize the boundary face outwards direction</span>
vl = sqrt(dot(bdFaceOutDirec,bdFaceOutDirec,2));
idx = (vl==0);
NeumannFace = face(~idx,:);
bdFaceOutDirec(idx,:) = [];
vl(idx) = [];
bdFaceOutDirec = bdFaceOutDirec./[vl vl vl];

display(DirichletFace);
display(NeumannFace);
display(bdFaceOutDirec);
</pre><pre class="codeoutput">
DirichletFace =

           2           3           7
           2           6           7


NeumannFace =

           1           2           3
           1           2           6
           1           3           4
           1           4           8
           1           5           6
           1           5           8
           3           4           7
           4           7           8
           5           6           7
           5           7           8


bdFaceOutDirec =

     0     0    -1
     0    -1     0
     0     0    -1
    -1     0     0
     0    -1     0
    -1     0     0
     0     1     0
     0     1     0
     0     0     1
     0     0     1

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Simplicial Complex in Three Dimensions
%
% We dsecribe the data structure of the simplicial complex associated to a
% two dimensional trianglulation give by |node,elem| . The |node| records
% the coordinates of vertices and |elem| is the pointer from local to
% global incices of vertices. See <meshbasicdoc.html Basic mesh data structure>.
%
% A brief summary of ordering and orientation
%
% * edge: asecond ordering, i.e. edge(:,1)<edge(:,2)
%
% * face: asecond ordering, i.e. face(:,1)<face(:,2)<face(:,3)
%
% * elem: positive ordering or ascend ordering. The default one is positive
% ordering and the asecond ordering is used for edge and face elements.
%
% Functions to call
%  
%  [elem2edge,edge,elem2edgeSign] = dof3edge(elem); 
%  [elem2face,face,elem2faceSign] = dof3face(elem);
%
% Functions to read on the usage
%
%  Poisson3RT0;
%  Maxwell;
%  Maxwell2;

%%
% The basic data structure of a mesh consists of node and elem:
elem = [1 4 5 8; 1 4 5 7];
node = [1,0,0; 1,1,1; 1,-1,-1; 0,1,0; -2,-1,0; 1,1,-1; 0,1,1; 0,-1,-1];
%%
% The corresponding simplicial complex consists of vertices, edges, faces
% and tetrahedron. We shall discuss three issues 
%
% * *Indexing* of simplexes
% * *Ordering* of vertices
% * *Orientation* of simplexes
%
% The indexing and ordering are related and the ordering and orientation
% are mixed together. However the indexing has nothing to do with the
% orientation. The indexing and ordering is the combinatory structure, i.e.
% only |elem| is needed, while the orientation also depends on |node|, the
% geometry emembdding of vertices.
%
% For indexing, ordering, and orientation, there are always local and
% global version. The relation between the local and global version is the
% most complicated issue. 
%

%% Indexing of Simplexes
%
% The indexing refers to the numbering of simplexes, e.g., which face/edge
% is numbered as the first one. There are two types of indexing: local and
% global. In the assembling procedure of finite element methods, an
% element-wise matrix using local indexing is first computed and then
% assembled to get a big matrix using global indexing. Thus the pointer
% from local indexing to global indexing is indispensible. And for bases
% independent of the ordering and orientation, e.g., P1 and P2 elements,
% the pointer is sufficient. Otherwise the inconsistency of local
% ordering/orientation and global ordering/orientation should be take into
% account.
%
% *Local indexing*
%
% The tetrahedron consists of four vertices indexed as [1 2 3 4]. Each
% tetrahedron contains four faces and six edges. They can be indexed as
locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
%%
% In |locFace|, the i-th face is opposite to the i-th vertices and thus
% this is called _opposite indexing_. In |locEdge|, it is the
% _lexicographic indexing_ which is induced from the lexicographic ordering
% of the six edges. The ordering of vertices of each face or edge will not
% change the indexing. For example, the following |locFacec| and |locEdged|
% has the same indexing as |locFace| and |locEdge| but a different ordering
% of vertices.
locFacec = [2 3 4; 1 4 3; 1 2 4; 1 3 2];
locEdge = [2 1; 3 1; 4 1; 3 2; 4 2; 4 3];
%%
% Indeed any permuation of each simplex will represent the same simplex and
% will not change the indexing. The ordering of vertices will affect the
% orientation and will be discussed later.

%%
% For a face consists of three vertices [1 2 3], there are two indexing
% schemes of its three edges.
%
% # Oppoiste indexing        |[2 3; 3 1; 1 2]|
% # Lexicographic indexing   |[1 2; 1 3; 2 3]|
%
% Each indexing scheme has its advantange and disadavantange and which one
% to chose depends on the ordering and orientation consideration.

%%
% *Global indexing and vertex pointer*
%
% Each simplex in the simplicial complex has a unqiuely index. It is
% represented by vertices pointer from the local index to the globa index
% of vertices.
%
% The matrix |elem| is the pointer from local to global indices of vertices
% of tetrahedron, e.g. |elem(t,1)=25| means the first vertex of the
% tetrahedron t is the 25-th vertex.
%
% Similarly the |NE| by 2 matrix |edge| records all edges and the |NF| by 3
% matrix |face| records all faces of the triangulation. These are vertices
% pointers. We shall discuss the elementwise pointer from local indices to
% global indices for edges and faces.

%% Generate |edge| and |face| and Index Pointers
%
% One can easily collect edges and faces elementwise. The issue is the
% duplication. For example, each interior face will be counted twice. The
% |unique| function is applied such that each edge or face has a unique
% global index.
%
% *Edge and Face*
totalEdge = uint32([elem(:,[1 2]); elem(:,[1 3]); elem(:,[1 4]); ...
                    elem(:,[2 3]); elem(:,[2 4]); elem(:,[3 4])]);
sortedTotalEdge = sort(totalEdge,2);
[edge, NULL, je] = unique(sortedTotalEdge,'rows');

totalFace = uint32([elem(:,[2 3 4]); elem(:,[1 4 3]); ...
                    elem(:,[1 2 4]); elem(:,[1 3 2])]);
sortedTotalFace = sort(totalFace,2);                
[face, i2, jf] = unique(sortedTotalFace,'rows');

%% 
% In iFEM, |N,NE,NF,NT| represents the number of vertices, edges, faces and
% tetrahedrons, resprectively.
N = size(node,1); NT = size(elem,1); NF = size(face,1); NE = size(edge,1);

%%
% In the assembling procedure, the matrix is always computed elementwise
% and then assemble to a big one. A pointer from the local index of a
% simplex to its global index is thus indispensible.
%
% *Elementwise pointers*
%
% * |elem2node = elem|
% * |elem2face(1:NT, 1:4)|
% * |elem2edge(1:NT, 1:6)|
%
% Such information is exactly stored in the output of |unique| function.
% For example, elem2face(t,1) = 17 means the first face of t (spanned by [2
% 3 4]) is the 17-th element in the |face| matrix. 
elem2edge = uint32(reshape(je,NT,6));
elem2face = uint32(reshape(jf,NT,4));

%%
% *Face to edge Pointer*
%
% |face2edge(1:NF,1:3)| records the global indices of three edges of a
% face. This pointer depends on the ordering of vertices of faces and the
% indexing of local edges in a face. We list the following two important
% cases. Other combinations is possible but not attractive.
%
% * Ascend ordering.
%
% All locaal faces and local edges are ascend ordered.
locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
edgeofFace = [1 2; 1 3; 2 3];
locface2edge = [4 5 6; 2 3 6; 1 3 5; 1 2 4];
%%
% * Consistent ordering
%
% The local face is ordered such that the corresponding orientation is
% consistent with the induced orientation.
locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
edgeofFace = [2 3; 3 1; 1 2];   
locface2edge = [6 5 4; 6 2 3; 5 3 1; 4 1 2];

%%
% The global one can be obtained from the composition of |elem2face| and
% |locface2edge|. For example, for the asecnd ordering scheme,
face2edge(elem2face(:,1),:) = elem2edge(:,[4 5 6]);
face2edge(elem2face(:,2),:) = elem2edge(:,[2 3 6]);
face2edge(elem2face(:,3),:) = elem2edge(:,[1 3 5]);
face2edge(elem2face(:,4),:) = elem2edge(:,[1 2 4]);

%% Ordering of Vertices
%
% We discuss the ordering of vertices of simplexes. Again there are local
% ordering and global ordering. They may not be consistent and a sign array
% is used to record the inconsistency if any.
%
% The local ordering refers to the ordering of vertices in |locFace| or
% |locEdge|, i.e. the ordering of the local index of vertices. For elements
% associated to faces or edges, the local ordering could be used in the
% formulation of the local basis and thus the ordering does matter.
%
% The global ordering refers to the ordering of vertices in |face| or
% |edge|, i.e., the ordering of the global index of vertices. Note that
% that in either local or global ordering, permutation of vertices will
% represent the same simplex. To fix an ordering we need extra information.
%
% *elem*. The local ordering is always [1 2 3 4]. Any permutation of four
% vertices of a tetrahedon still represents the same tetrahedron. Such
% freedom provide a room to record more information like:
%
% * global ordering of vertices
% * orientation of element
% * refinement rule
%
% In 2-D, three vertices of a triangle is sorted counter-clockwise and the
% first vertex is chosen as the newest vertex. Such ordering enables the
% efficient implementation of local refinement and coarsening in 2-D; see
% <bisectdoc.html Bisection in Two Dimensions> and <coarsendoc.html
% Coarsening in Two Dimensions>. In 3-D, for the longest edge bisection,
% the newest vertex (with the highest generation) is stored as the last
% (4-th) vertex of a tetrahedron. For <uniformrefine3doc.html 3-D Red
% Refinement>, the ordering determines the shape regularity of refined
% triangulation. Permuation of vertices in |elem| could deterioriate the
% angle condition after the refinement.
%
% We shall reserve the ordering of |elem| for the mesh refinement and
% coarsening since they are more subtle. We switch the ordering when
% generating data structure for finite element basis and assemble the
% matrix equation. Such sorting is hidden in the subroutines when a finite
% element basis requiring ordering is generated.
%
% Two types of ordering of |elem| is of particular importantance
%
% * Positive ordering
% * Ascend ordering
%
% In the positive ordering, the four vertices are ordered such that the
% signed volume, the mix product of vectors (v12,v13,v14), is positive.
% This is the default ordering used so far. |fixorder3| will switch the
% vertices for elements with negative volume. 
%
% * |v = simplexvolume(node,elem)| returns the singed area
% * |elem = fixorder(node,elem)| switchs the vertices for elements with
% negative area.
%
%%
% In ascend ordering, the vertices of |elem| is sorted such that |elem(t,1)
% < elem(t,2) < elem(t,3) < elem(t,4)|. Such ordering will benefit the
% construction of local bases for high order basis or basis with
% orientation. This can be easily achieved by |elem = sort(elem,2)|.
% Howevery, one has to rotate the boundary flag accordingly using
elem = sortelem3(elem);
%%
% *edge*. For 3-D triangulations, we chose the ascend ordering both locally
% and globally. Namely
locEdge(:,1) < locEdge(:,2); 
edge(:,1) < edge(:,2);
%%
% Recall that for locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4], it is ascend
% ordered. The |edge| produced by |unique| function is also ascend
% ordered. 
%
% There might be a inconsistency between the local and global ordering.
% That is |edge(elem2edge(t,1),1)| may not be smaller than
% |edge(elem2edge(t,1),2)|. It will be more clear from the discussion of
% the corresponding orientation.
%
% For 2-D triangulations, the global ordering is still ascend ordered. But
% locally it may not. For example, for consisitent ordering |locEdge = [2
% 3; 3 1; 1 2]|, then |locEdge(2,1) > locEdge(2,2)|.
%%
% *face*. For 3-D triangulations, the |face| produced by |unique| function is
% already sorted in the second dimension such that the global ordering is
% ascended i.e. |face(:,1) < face(:,2) < face(:,3)|. The local ordering in
% |locFace|, however, is not always ascend ordered.
locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3]; % Ascend ordering
locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2]; % Consistent ordering
%%
% Again the local and global ordering maynot be consisitent. That is
% |face(elem2face(t,:),1) < face(elem2face(t,:),2) < face(elem2face(t,:),3)|
% maynot be true.

%% Orientation of Simplexes
%
% The orientation of a tetrahedron is either positive or negative. The
% orientation of a face is given by a normal vector and the orientation of
% an edge is by a tangential vector. 
%
% The orientation of a d-simplex will induce an orientation of its d-1
% subcomplex and is called _induced orientation_. For example, a positive
% orientated tetrahedron will induce the outwards normal orientation of its
% four faces and a positive orientated triangle will induce the counter
% clockwise orientation of its three edges.
%
% The ordering of vertices of a simplex will naturally introduce an
% orientation and will be called _ordering orientation_. More specifically
%
% * the vector from edge(:,1) to edge(:,2) defines an orientation of edges.
% * the |cross(v12,v13)| defines an orientation of a face, where |vij| is
% the vector from |face(:,i)| to |face(:,j)|.
% * the sign of the mix product |sign(v12, v13, v14)| defines an
% orientation for tetrahedrons.
%
% The orientation of a simplex in the simplicial complex should be uniquely
% determined which will be called _global orientation_. It can be chosen as
% the global ordering orientation but not always.
%
% Inside one tetrahedron, the local ordering of local edges and local faces
% will introduce a corresponding orientation. The orientation of the
% tetrahedron will also induce an orientation for its four faces. These are
% called _local orientation_ which may not be consisitent with the global
% orientation. The local ordering orientation is used in the local basis
% and the induced orientation is used when computing the differential
% operator locally.
%
% In general, there will be a inconsistency of the following several types
% of orientation and apporipate data structure should be constructured to
% record such inconsistency.
%
% * a global orientation
% * the global ordering orientation
% * the local ordering orientation inside a tetrahedron
% * the local induced orientation inside a tetrahedron
%
% *elem*. The orientation of a tetraheron is either positive or negative.
% We chose the global ordering orientation, i.e., the sign of the signed
% volume. 
[Dlambda,volume,elemSign] = gradbasis3(node,elem);
%%
% In the output of |gradbasis3|, |volume| is always positive and an
% additional array |elemSign| is used to record the sign of the signed
% volume.
%
% |Dlambda(t,:,k)| is the gradient of $\lambda_k$. Therefore the outward
% normal direction of the kth face can be obtained by |-Dlambda(t,:,k)|
% which is independent of the ordering and orientation.
%
% *face*. The global ordering orientation. The normal vector is given by
% |cross(v12,v13)|.
%
% The local ordering orientation is implicitly used when computing finite
% element basis in each element. For example, the RT0 basis on face |[i j
% k]| in |locFace| is defined as
%
% $$\phi_{i,j,k} = 2(\lambda_i
% \nabla \lambda_j \times \nabla \lambda_k+ \lambda_j
% \nabla \lambda_k \times \nabla \lambda_i+\lambda_k
% \nabla \lambda_i \times \nabla \lambda_j).$$ 
%
% Odd permutation of |[i j k]| will change the sign of the basis. The
% direction of $\phi_{i,j,k}$ is the normal vector determined by |[i,j,k]|
% ordering. Note that this is locally, i.e., element by element. 
%
% The global basis associated to a face, however, depends only on the
% global orientation of this face. We introduce |elem2faceSign(1:NT, 1:4)|
% to record the inconsistency of a local ordering orientation and a global
% orientation.
%
% For locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2], i.e. the induced ordering,
% the elem2faceSign can be obtained from |dof3face|
totalFace = [elem(:,[2 3 4]); elem(:,[1 4 3]); elem(:,[1 2 4]); elem(:,[1 3 2])];
elem2faceSign = reshape(sum(sign(diff(totalFace(:,[1:3,1]),1,2)),2),NT,4);      
%%
% When both |elem| and |locFace| are ascend ordered, the orientation of the
% global ordering is consistent with the local ordering. Thus
% |elem2faceSign| is not needed for ascending ordering when assembling
% matrices of weak form.
%
% But for asecond ordering system, an |elem2faceSign| will be used when
% assembling differential operators. For example, when computing |div|
% operators on a positive orientated tetrahedron, the faces should be
% orientated by the outwards normal direction but the global faces may not be.
%
% If |elem| is positive ordered and |locFace| is consistently ordered, then
% this inconsistency is already recorded in |elem2faceSign|.
%
% For ascend ordering of |elem|, we denote the direction as +1 if the
% direction of a face is the same with the induced normal direction in a
% certain elem, and -1 otherwise. Then the consistency is given by
elem2faceSign = [+1 -1 +1 -1];

%%
%
% *edge*. The orientation of edges is simpler than faces. Globally we
% always chose the global ascend ordering orientation. Namely the
% orientation of an edge is from the smaller index to larger index.
%
% Locally the local ascend ordering may not be consistent with the global
% one. See <dof3edgedoc.html Data Structure: Lowest Order Edge Element>.
totalEdge = uint32([elem(:,[1 2]); elem(:,[1 3]); elem(:,[1 4]); ...
                    elem(:,[2 3]); elem(:,[2 4]); elem(:,[3 4])]);
direction = ones(6*NT,1,'int8');
idx = (totalEdge(:,1)>totalEdge(:,2));
direction(idx) = -1;
elem2edgeSign = reshape(direction,NT,6);

%%
% 
% For ascend ordering of |elem| and |locEdge|, the local and global
% orientation will be consistent and no |elem2edgeSign| is needed!
%
% *face to edge*. For the ascend ordering |edgeofFace = [1 2; 1 3; 2 3]|,
% the local and global ordering is consistent and so is the orientation.
% But it is not consisitent with the induced positive (counter clockwise)
% orientation of edges. When the edge direction is the same with the local
% counter clockwise direction, we set the direction as +1, otherwise -1.
% Then
face2edgeSign = [+1 -1 +1];

%%
% For the consistent ordering, |edgeofFace = [2 3; 3 1; 1 2]| which is
% consisent with the induced positive orientation but not consistent with
% the global orientation of edges. We construct |face2edgeSign| as
totalEdge = [face(:,[2 3]); face(:,[3 1]); face(:,[1 2])];
direction = ones(3*NF,1);
idx = (totalEdge(:,1)>totalEdge(:,2));
direction(idx) = -1;
face2edgeSignp = reshape(direction,NF,3);
%%
% We summarize the two popular ordering and orientation schemes below.

%% Ascend Odering and Orientation
%
% *Ascend ordering*.
% The vertices of |elem| is sorted such that
%
% |elem(i,1) < elem(i,2) < elem(i,3) < elem(i,4)|. 
%
% The local face and local edges is also in the ascend ordering
%
% * |locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];|
% * |locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];|
% * |edgeofFace = [1 2; 1 3; 2 3];|
%
% Then due to the asecond ordering of |elem|, globally the |edge| and
% |face| also follow the ascend ordering, i.e.
%
% * |edge(e,1) < edge(e,2)| 
% * |face(f,1) < face(f,2) < face(f,3)| 
%
% One can easily see the benefit: the ordering of local edges and local
% faces is consistent with the global ones and so is their corresponding
% orientation.
%
% *Orientation*. We chose the global ordering orientation for each elment.
% We chose the orientation corresponding to the ascend ordering for edges
% and faces. We summarize as
%
% * elem: |sign(v12,v13,v14)|
% * face: the normal vector is given by |cross(v12,v13)|
% * edge: from the node with smaller global index to bigger one
%
% For faces and edges, the orientation of the global ordering and the local
% ordering of faces and edges is consistent. The inconsistency of the
% ordering orientation and the induced orienation is recorded by
%
% * elem2faceSign = [+1 -1 +1 -1];
% * face2edgeSign = [+1 -1 +1];

%% Positive Ordering and Orientation
%
% *Positive and consistent ordering*.
% The vertices of |elem| is sorted such that the signed volume is always
% positive, i.e. the four vertices follows the right hand rule.
%
% The local face is ordered consistently as 
%
% |locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];|
%
% The local edge is still ascend ordered
%
% locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
%
% Three edges of a face is ordered consistently
%
% edgeofFace = [2 3; 3 1; 1 2];
%
% *Orientation* 
%
% The ascend ordering orientation is used for global edges and faces. The
% inconsistency of the local and global orientation is recorded in
% |elem2faceSign| and |elem2edgeSign|.

%% An Example 
% We show two tetrahedron with ascend ordering.
elem = [1 4 5 8; 1 4 5 7];
figure(1);clf;
showmesh3(node,elem);
view(-1,32);
findnode3(node,[1,2,3,4,5,7,8]);
findelem3(node,elem);
findedge(node,edge,'all','vec');
findelem(node,face);
snapnow;
display(edge); display(elem2edge);
display(face); display(elem2face);
display(elemSign);
display(elem2faceSign);
display(face2edgeSign);

%% Boundary Faces and Boundary Conditions
%
% We use |bdFlag| to record the boundary condition; see <bddoc.html Data
% Structure: Boundary Conditions> for details. For short, |bdFlag| has the
% same size with |elem|, and point to the boundary type of each local
% faces. If we change the ordering of |elem|, the corresponding local faces
% are changed. Threfore when we sort the |elem|, we should sort the
% |bdFlag| respectively. We use |sortelem3| to sort elem and bdFlag at the
% same time. Note that |sort(elem,2)| sorts the |elem| only, and leave
% |bdFlag| unchanged.

[node,elem] = cubemesh([-1,1,-1,1,-1,1],2);
bdFlag = setboundary3(node,elem,'Dirichlet','x==1','Neumann','x~=1');
figure(2);clf;
showmesh3(node,elem);
display(elem); display(bdFlag);
findnode3(node,[1,2,3,4,5,7,8]);
[elem,bdFlag] = sortelem3(elem,bdFlag);
display(elem); display(bdFlag);
%%
% We can use |bdFlag| to find the boundary nodes, edges and faces. To find
% the outwords normal direction of the boundary face, we need the help of
% the |gradbasis3|. In the output of |gradbasis3|, |Dlambda(t,:,k)| is the
% gradient of $\lambda_k$. Therefore the outward normal direction of the
% kth face can be obtained by |-Dlambda(t,:,k)| which is independent of the
% ordering and orientation.

Dlambda = gradbasis3(node,elem);
T = auxstructure3(elem);
elem2face = T.elem2face; 
face = T.face;
NF = size(face,1);
if ~isempty(bdFlag)
    % Find Dirchelt boundary faces and nodes
    isBdFace = false(NF,1);
    isBdFace(elem2face(bdFlag(:,1) == 1,1)) = true;
    isBdFace(elem2face(bdFlag(:,2) == 1,2)) = true;
    isBdFace(elem2face(bdFlag(:,3) == 1,3)) = true; 
    isBdFace(elem2face(bdFlag(:,4) == 1,4)) = true;
    DirichletFace = face(isBdFace,:);
    % Find outwards normal direction of Neumann boundary faces
    bdFaceOutDirec = zeros(NF,3);
    bdFaceOutDirec(elem2face(bdFlag(:,1) == 2,1),:) = -Dlambda(bdFlag(:,1) == 2,:,1);
    bdFaceOutDirec(elem2face(bdFlag(:,2) == 2,2),:) = -Dlambda(bdFlag(:,2) == 2,:,2);
    bdFaceOutDirec(elem2face(bdFlag(:,3) == 2,3),:) = -Dlambda(bdFlag(:,3) == 2,:,3);
    bdFaceOutDirec(elem2face(bdFlag(:,4) == 2,4),:) = -Dlambda(bdFlag(:,4) == 2,:,4);
end
% normalize the boundary face outwards direction
vl = sqrt(dot(bdFaceOutDirec,bdFaceOutDirec,2));
idx = (vl==0);
NeumannFace = face(~idx,:);
bdFaceOutDirec(idx,:) = [];
vl(idx) = [];
bdFaceOutDirec = bdFaceOutDirec./[vl vl vl];

display(DirichletFace);
display(NeumannFace);
display(bdFaceOutDirec);



##### SOURCE END #####
--></body></html>